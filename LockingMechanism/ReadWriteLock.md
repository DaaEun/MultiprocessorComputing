## ReadWriteLock.java 조건 정의

    1. 읽기 접근 : 쓰기 작업을 수행중인 다른 쓰레드가 없고, 쓰기 접근을 요청한 다른 쓰레드도 없을 때
     
    2. 쓰기 접근 : 쓰기와 읽기 작업을 수행중인 다른 쓰레드가 없을 때


    - 한 쓰레드가 자원을 읽으려 할 때, 이 지원에 쓰기 작업을 수행 중이거나 쓰기 작업을 수행하기 위한 접근을 요청한 다른 쓰레드가 존재하지 않는다면 이 읽기 작업에는 아무런 문제가 없다. 

    - 쓰기 접근을 시도하는 쓰레드는 모든 읽기 요청이 ReadWriteLock 을 해제할 때까지 블록된다. 

    - 만약 새로운 쓰레드들이 거듭 읽기 접근을 획득한다면, 쓰기 작업을 위해 대기중인 쓰레드는 무기한 블록 상태로 남게 될 것이다. 따라서 쓰기 접근을 위해 ReadWriteLock 에 락을 걸거나(이미 걸었거나) 락을 요청한 쓰레드가 없는 경우에만 읽기 접근이 허용된다.

    - 자원에 대한 쓰기 접근을 요하는 쓰레드는 다른 쓰레드들이 이 자원에 읽기나 쓰기 작업 중이 아닐 때 접근이 허용된다.

***

## unlockRead()와 unlockWrite() 메소드에서 notify()가 아닌 notifyAll()을 호출하는 이유

- 쓰기/읽기 접근을 위해 대기중인 다수의 쓰레드들이 있을 때 notify()가 호출되어 읽기 접근 대기 중이던 쓰레드가 깨어나면 이 쓰레드는 다시 대기 상태로 돌아갈 것이다.   
왜냐하면 쓰기 접근으로 대기중인 쓰레드가 존재하기 때문이다. 하지만 여기서 쓰기 대기중인 쓰레드는 깨어나지 못한다. 그리고 이후로 아무 일도 일어나지 않는다. 읽기나 쓰기 접근 중 어느 쪽도 허용되지 못하게 된다. 

- 이상의 현상을 방지하기 위해 일단 notifyAll() 호출을 통해 모든 대기중인 쓰레드를 깨운 뒤, 쓰레드들이 자신이 요청한 접근 권한을 획득할 수 있는지 확인하도록 하기 위해 notifyAll()을 사용한다.
또한 다수의 쓰레드들이 읽기 접근 대기중이고 쓰기 접근 요청이 없는 경우에, 쓰레드를 하나씩 Wakeup할필용없이 한 번의 unlockWrite() 호출만으로 모든 대기중인 읽기 접근을 허용할 수 있다. 

***

#### _[ReadWriteLock.java](https://github.com/DaaEun/MultiprocessorComputing/blob/main/LockingMechanism/src/ReadWriteLock.java) 코드 바로가기_  